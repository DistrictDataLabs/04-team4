<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
<title>Our Super-Quick Introduction to BioFabric</title>
<style>
.emph {font-style: italic;}
.linktext00 {font: 25px sans-serif; fill: #000000; text-anchor: middle;}
.linktext0 {font: 100px sans-serif; fill: #000000; text-anchor: middle;}
.narrText {font: 18px sans-serif; fill: #000000; }
.linktext2 {font: 80px sans-serif; fill: #000000; text-anchor: middle;}
.linktext3 {font: 80px sans-serif; fill: #000000; text-anchor: middle;}
.linktext4 {font: 50px sans-serif; fill: #000000; text-anchor: middle;}
.nodeLabel {font: 10px sans-serif; fill: #000000; text-anchor: end;}
.zoneLabel {font: 40px sans-serif; fill: #000000; text-anchor: middle;}
.inner {width: 1200px; margin: 0 auto;}
.all {height:100%; width:100%; overflow:auto; background-color: #ffffff;}
.myHeading {min-height:100px; height:auto; height:100px; width:100%;}
.myCan {width:100%;}
.myData {width: 1200px; margin: 0 auto; font: 14px sans-serif; fill: #000000; text-anchor: middle;}

</style>
</head>
<body>
  <div id="whole" class="all">
    <div id="spacer" class="myHeading">
    </div>
    <div id="outer" class="myCan">  
      <div class="inner"></div>
      <div id="data" class="myData"></div>
    </div>   
  </div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

////////////////////////////////////////////////////////////////////////////////
//
// Released under "The MIT License":
//
// Copyright (c) 2013 William J.R. Longabaugh
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
// Data to build the color cycle
//

var tagOrder = ["EX-blue",
    "EX-orange",
    "EX-dark-cyan",
    "EX-red",
    "EX-dark-orange",
    "EX-dark-gray-purple",
    "EX-cyan",
    "EX-yellow-orange",
    "EX-pure-blue",
    "EX-dark-yellow-green",
    "EX-dark-magenta",
    "EX-dark-green",
    "EX-blue-magenta",
    "EX-yellow-green",
    "EX-magenta",
    "EX-green",
    "EX-yellow",
    "EX-purple",
    "EX-dark-purple",
    "EX-dark-red",
    "EX-pale-green",
    "EX-pale-blue",
    "EX-dark-tan",
    "EX-pale-blue-magenta",
    "EX-pale-yellow orange",
    "EX-medium-magenta",
    "EX-pale-red",
    "EX-pale-cyan",
    "EX-pale-yellow-green",
    "EX-pale-purple",
    "EX-pale-magenta",
    "EX-pale-red-orange"];

var baseColors = {
     "EX-cyan":{"r":0, "g":255, "b":255},
     "EX-dark-cyan":{"r":0, "g":100, "b":128},
     "EX-yellow-orange":{"r":255, "g":153, "b":0},
     "EX-pale-green":{"r":133, "g":205, "b":102},
     "EX-dark-green":{"r":39, "g":128, "b":0},
     "EX-pale-red-orange":{"r":230, "g":156, "b":138},
     "EX-yellow-green":{"r":154, "g":255, "b":0},
     "EX-yellow":{"r":255, "g":203, "b":0},
     "EX-dark-gray-purple":{"r":0, "g":25, "b":128},
     "EX-pale-magenta":{"r":212, "g":138, "b":230},
     "EX-pale-purple":{"r":149, "g":165, "b":230},
     "EX-purple":{"r":102, "g":51, "b":255},
     "EX-dark-red":{"r":140, "g":56, "b":56},
     "EX-red":{"r":255, "g":0, "b":0},
     "EX-pale-yellow-green":{"r":222, "g":230, "b":138},
     "EX-dark-purple":{"r":77, "g":56, "b":140},
     "EX-pale-cyan":{"r":138, "g":230, "b":181},
     "EX-pure-blue":{"r":0, "g":0, "b":255},
     "EX-dark-yellow-green":{"r":114, "g":128, "b":0},
     "EX-magenta":{"r":255, "g":0, "b":255},
     "EX-dark-tan":{"r":166, "g":133, "b":83},
     "EX-pale-blue":{"r":102, "g":183, "b":205},
     "EX-orange":{"r":255, "g":103, "b":0},
     "EX-medium-magenta":{"r":166, "g":83, "b":166},
     "EX-blue-magenta":{"r":155, "g":0, "b":255},
     "EX-green":{"r":0, "g":255, "b":0},
     "EX-dark-magenta":{"r":102, "g":0, "b":128},
     "EX-pale-blue-magenta":{"r":146, "g":102, "b":205},
     "EX-pale-yellow orange":{"r":205, "g":175, "b":102},
     "EX-dark-orange":{"r":128, "g":92, "b":0},
     "EX-blue":{"r":0, "g":152, "b":255},
     "EX-pale-red":{"r":205, "g":102, "b":153}
  };

///////////////////////////////////////////////////////////////////
//
// Constants:
//

var ONE_SEC = 1000;
//var BASE_TRANS = ONE_SEC;
var BASE_TRANS = 100;
var LINK_COL = d3.rgb(0, 71, 90);
var NODE_COL = d3.rgb(255, 147, 0);
var clickNum = 0;
var width = 1200;
var hw = width / 2;
var height = 500;
var hh = height / 2;
var PAD = 40;
var GRID = 18;
var NODE_SIZE = 16;
var NODE_HALF = NODE_SIZE / 2;
var LINK_WIDTH = 10;
var NODE_WIDTH = 3;
var WRAP_LOC_X = .87;

///////////////////////////////////////////////////////////////////
//
// Turn the nodes into long lines:
//

function nodeToLinesClosure(mySvg, myWidth, sec) {
 return (function () { nodeToLines(mySvg, myWidth, sec); });
}

function nodeToLines(mySvg, myWidth, sec) {
 d3.selectAll(".node")
      .transition().duration(sec * BASE_TRANS)
      .attr("x1", function(d) { return (d.x - (myWidth * 1.5)); })
      .attr("x2", function(d) { return (d.x + (myWidth * 1.5)); })
      .style("stroke-width", NODE_WIDTH);
}

///////////////////////////////////////////////////////////////////
//
// Fix the initial conditions:
//

function assignNodesToCircle(myGraph, radius, cx, cy) {
  myGraph.nodes.forEach(function(d, i) { d.x = cx + (radius * Math.sin((Math.PI * 2) * (i / myGraph.nodes.length))); 
                                       d.y = cy + (radius * Math.cos((Math.PI * 2) * (i / myGraph.nodes.length)));
                                     });
}

///////////////////////////////////////////////////////////////////
//
// Text stepping function with extra delay
//

function nextStepEx(mySvg, myText, myFunc, exTime) {
  mySvg.selectAll(".narrText")
       .transition().duration(100 + exTime).style("opacity", "0.0")
       .each("end", function() {mySvg.selectAll(".narrText")
                                     .transition().duration(50).text(myText)
                                     .each("end", function() { mySvg.selectAll(".narrText")
                                                                    .transition().duration(500).style("opacity", "1.0")
                                                                    .each("end", myFunc);
                                                              })
                                });
}

///////////////////////////////////////////////////////////////////
//
// Text stepping function:
//

function nextStep(mySvg, myText, myFunc) {
  nextStepEx(mySvg, myText, myFunc, 0); 
}

///////////////////////////////////////////////////////////////////
//
// Ditch the title
//

function ditchTitle(mySvg, fadeTime) {
  mySvg.selectAll(".linktext00, .linktext0")
       .transition()
       .duration(fadeTime * BASE_TRANS).style("opacity", 0)
       .each("end", function() { mySvg.selectAll(".linktext00, .linktext0").remove();});
}

///////////////////////////////////////////////////////////////////
//
// Install wrapup text
//

function wrapItUp(mySvg, myHeight, myWidth, xLoc, wrapFade) {
  var textA = "(nodes == lines) -> !hairballs";
  var textB = "www.BioFabric.org";
  var textC = "Click here to replay...";
  var yLoc = .25;

  // Same deal here, FireFox choking unless stuff is given in a transform:
  mySvg.append("svg:text")
       .attr("class", "linktext2")
       .attr("transform", function(d) { return "translate(" + (myWidth * xLoc) + "," + ((myHeight * yLoc) - 130) + ")"; })
       //.attr("dx", myWidth * xLoc)
       //.attr("dy", (myHeight * yLoc) - 130)
       .text(textA).style("opacity", "0.0");
  mySvg.append("svg:text")
       .attr("class", "linktext3")
       .attr("transform", function(d) { return "translate(" + (myWidth * xLoc) + "," + (myHeight * yLoc) + ")"; })
       //.attr("dx", myWidth * xLoc)
       //.attr("dy", (myHeight * yLoc))
       .text(textB).style("opacity", "0.0");
  mySvg.append("svg:text")
       .attr("class", "linktext4")
       .attr("transform", function(d) { return "translate(" + (myWidth * xLoc) + "," + ((myHeight * yLoc) + 130) + ")"; })
       //.attr("dx", myWidth * xLoc)
       //.attr("dy", (myHeight * yLoc) + 130)
       .text(textC).style("opacity", "0.0");
  mySvg.selectAll(".linktext2").transition().duration(wrapFade * BASE_TRANS).style("opacity", 1);
}

///////////////////////////////////////////////////////////////////
//
// Slide all the links to the final vertical positions:
//

function linksToVertClosure(mySvg, mySec) {
  return (function () { linksToVert(mySvg, mySec); });
}

function linksToVert(mySvg, mySec) {

mySvg.selectAll(".linkB")
       .transition()
       .attr("x1", function(d) { return PAD + d.col * GRID; })
       .attr("y1", function(d) { return PAD + d.source.row * GRID; })
       .attr("x2", function(d) { return PAD + d.col* GRID; })
       .attr("y2", function(d) { return PAD + d.target.row * GRID; })
       .duration(mySec * BASE_TRANS);

  mySvg.selectAll(".linkF")
       .transition()
       .attr("x1", function(d) { return PAD + d.col * GRID; })
       .attr("y1", function(d) { return PAD + d.source.row * GRID; })
       .attr("x2", function(d) { return PAD + d.col* GRID; })
       .attr("y2", function(d) { return PAD + d.target.row * GRID; })
       .duration(mySec * BASE_TRANS);
}

///////////////////////////////////////////////////////////////////
//
// Generate colors from the color cycle
//

function cycleColor(mult) {
  return function(d, i) { 
    var tag = tagOrder[i % tagOrder.length];
    var myR = Math.min(255, baseColors[tag].r * mult);
    var myG = Math.min(255, baseColors[tag].g * mult);
    var myB = Math.min(255, baseColors[tag].b * mult);
    return (d3.rgb(myR, myG, myB));
  }
}
 
///////////////////////////////////////////////////////////////////
//
// Color the nodes and the links:
//

function colorNodesAndLinksClosure(mySvg, val, mySec) {
  return (function () { colorNodesAndLinks(mySvg, val, mySec); });
}

function colorNodesAndLinks(mySvg, val, mySec) {
  mySvg.selectAll(".node")
        .transition()
        .duration(mySec * BASE_TRANS)
        .style("stroke", cycleColor(val));

  mySvg.selectAll(".linkF")
        .transition()
        .duration(mySec * BASE_TRANS)
        .style("stroke", cycleColor(1 / val));
}

///////////////////////////////////////////////////////////////////
//
// Draw the endpoint glyphs while bringing the links forward:
//

function drawGlyphsClosure(mySvg, myGraph, mySec) {
  return (function () { drawGlyphs(mySvg, myGraph, mySec); });
}

function drawGlyphs(mySvg, myGraph, mySec) {

  var myg = mySvg.selectAll(".glyph")
      .data(myGraph.links)
      .enter().append("svg:rect")
      .attr("class", "glyph")
      .attr("x", function(d) {return PAD + d.col* GRID - 5; })
      .attr("y", function(d) {return PAD + d.source.row * GRID - 5; })
      .attr("width", 10)
      .attr("height", 10)
      .style("stroke-width", function(d) { return 4; })
      .style("stroke", "black")
      .style("fill", cycleColor(1/1.43))
      .style("opacity", "0.0")
      .append("svg:title")
      .text(function(d) { return d.source.name + "-" + d.target.name; });
  
 var myg2 = mySvg.selectAll(".glyph2")
      .data(myGraph.links)
      .enter().append("svg:rect")
      .attr("class", "glyph2")
      .attr("x", function(d) {return PAD + d.col * GRID - 5; })
      .attr("y", function(d) {return PAD + d.target.row * GRID - 5; })
      .attr("width", 10)
      .attr("height", 10)
      .style("stroke-width", function(d) { return 4; })
      .style("stroke", "black")
      .style("fill", cycleColor(1/1.43))
      .style("opacity", "0.0")
      .append("svg:title")
      .text(function(d) { return d.source.name + "-" + d.target.name; });
 
// Trying to change back link opacity to 0 at the same time gave weird behavior
// on my old browser. Make the lines 0 width and white instead before ditching 'em.
// Also, the glyphs don't do this last little "pulse" at the end if the opacity
// is < 1.0, at last on my old browser. Since this is a small demo, should not
// be a performance issue:
  
 mySvg.selectAll(".linkF, .glyph, .glyph2")
       .transition()
       .duration(mySec * BASE_TRANS)
       .style("opacity", "0.98");

 mySvg.selectAll(".linkB")
       .transition()
       .duration(mySec * BASE_TRANS)
       .style("stroke-width", 0)
       .style("stroke", "#FFFFFF").each("end", function() { mySvg.selectAll(".linkB").remove(); });
}

///////////////////////////////////////////////////////////////////
//
// Draw node labels:
//

function drawLabelsClosure(mySvg, myGraph, mySec) {
  return (function () { drawLabels(mySvg, myGraph, mySec); });
}

function drawLabels(mySvg, myGraph, mySec) {
  mySvg.selectAll(".nodeLabel")
       .data(myGraph.nodes)
       .enter().append("svg:text")
       .attr("class", "nodeLabel")
       .text(function(d) { return d.name; })
       .style("opacity", "0.0")
       .attr("x", function(d) { return PAD + (GRID * d.minCol); })
       .attr("y", function(d) { return PAD + (GRID * d.row); })
       .append("svg:title")
       .text(function(d) { return d.name; });

  var zlSel = mySvg.selectAll(".zoneLabel")
       .data(myGraph.nodes)
       .enter().append("svg:text")
       .attr("transform", function(d) { return "translate(" + (PAD + (GRID * (d.zoneMin + d.zoneMax) / 2)) + "," + (PAD + (GRID * (d.row - 1))) + ") scale(" + 1 + ")"; })
       .attr("class", "zoneLabel")
       .text(function(d) { return d.name; })
       .style("opacity", "0.0");

  zlSel.append("svg:title").text(function(d) { return d.name; });

  function sizeIt(d, i) {
    var bbw = zlSel[0][i].getBBox().width;
    var bbh = zlSel[0][i].getBBox().height;
    var sfac = (GRID * (d.zoneMax - d.zoneMin) * 0.667) / bbw;
    if (sfac > .33) {
      return "translate(" + (PAD + (GRID * (d.zoneMin + d.zoneMax) / 2)) + "," + (PAD + (GRID * (d.row - 1))) + ") scale(" + sfac  + ")";
    } else {
      return "translate(" + (PAD + (GRID * (d.zoneMin + d.zoneMax) / 2) + (0.4 * bbh / 2)) + "," + (PAD + (GRID * (d.row - 1)) - (0.4 * bbw / 2)) + ") rotate(" + -90  + ") scale(" + 0.4  + ")";
    }
  }
  zlSel.attr("transform", sizeIt);

  // Zone labels are anti-aliased better when opacity is < 1.0!
  mySvg.selectAll(".nodeLabel, .zoneLabel")
       .transition()
       .duration(mySec * BASE_TRANS)
       .style("opacity", "0.98");     
}


///////////////////////////////////////////////////////////////////
//
// Node sorting function based on degree and name:
//

function compareNodes(a, b) {
  if (a.degree < b.degree) {
     return 1;
  } else if (a.degree > b.degree) {
     return -1;
  } else {
     return (-a.name.localeCompare(b.name));
  }
}

///////////////////////////////////////////////////////////////////
//
// Set the node line lengths to final values:
//

function setNodeLengthClosure(mySvg, mySec) {
  return (function () { setNodeLength(mySvg, mySec); });
}

function setNodeLength(mySvg, mySec) {
 mySvg.selectAll(".node")
       .transition()
       .attr("x1", function(d) { return PAD + GRID * d.minCol; })
       .attr("x2", function(d) { return PAD + GRID * d.maxCol; })
       .duration(mySec * BASE_TRANS);
}

///////////////////////////////////////////////////////////////////
//
// Drop everything below the zoom transform
//

function dropAll(mySvg) {
  mySvg.selectAll("*").remove();
}

///////////////////////////////////////////////////////////////////
//
// Fade everything in:
//

function unfadeAll(mySvg) {
  mySvg.transition().duration(500).style("opacity", 1);
}

///////////////////////////////////////////////////////////////////
//
// Move nodes to final row positions:
//

function nodesToRowsClosure(mySvg, sec) {
  return (function () { nodesToRows(mySvg, sec); });
}

function nodesToRows(mySvg, sec) {
   mySvg.selectAll(".node")
       .transition()
       .attr("y1", function(d) { return PAD + (d.row * GRID); })
       .attr("y2", function(d) { return PAD + (d.row * GRID); })
       .duration(sec * BASE_TRANS);

  mySvg.selectAll(".linkB, .linkF")
       .transition()
       .attr("y1", function(d) { return PAD + d.source.row * GRID; })
       .attr("y2", function(d) { return PAD + d.target.row * GRID; })
       .duration(sec * BASE_TRANS);
}

///////////////////////////////////////////////////////////////////
//
// Run the D3 force layout w/o animation:
//

function instantForce(mySvg, myGraph, myWidth, myHeight) {
  var force = d3.layout.force()
                .charge(-120)
                .linkDistance(30)
                .size([myWidth, myHeight]);
  force.nodes(myGraph.nodes)
       .links(myGraph.links)
       .start();  
  var iters = 600;
  var thresh = 0.001;
  for (var i = iters; i > 0; i--) {
    force.tick();
    if (force.alpha() < thresh) {
      break;
    }
  }
  force.stop();
}

///////////////////////////////////////////////////////////////////
//
// Install the completed D3 force layout onto the graph. We apply a scale factor to make it bigger:
//

function installForceClosure(mySvg, myWidth, myHeight, sfac, mySec) {
  return (function () { installForce(mySvg, myWidth, myHeight, sfac, mySec); });
}

function installForce(mySvg, myWidth, myHeight, sfac, mySec) {
  mySvg.selectAll(".linkB")
       .attr("x1", function(d) { return ((d.source.x - (myWidth / 2)) / sfac) + (myWidth / 2); })
       .attr("y1", function(d) { return ((d.source.y - (myHeight / 2)) / sfac) + (myHeight / 2); })
       .attr("x2", function(d) { return ((d.target.x - (myWidth / 2)) / sfac) + (myWidth / 2); })
       .attr("y2", function(d) { return ((d.target.y - (myHeight / 2)) / sfac) + (myHeight / 2); })
       .transition().duration(mySec * BASE_TRANS)
       .style("opacity", "1.0");
  mySvg.selectAll(".linkF")
       .attr("x1", function(d) { return ((d.source.x - (myWidth / 2)) / sfac) + (myWidth / 2);; })
       .attr("y1", function(d) { return ((d.source.y - (myHeight / 2)) / sfac) + (myHeight / 2); })
       .attr("x2", function(d) { return ((d.target.x - (myWidth / 2)) / sfac) + (myWidth / 2);; })
       .attr("y2", function(d) { return ((d.target.y - (myHeight / 2)) / sfac) + (myHeight / 2); });
  mySvg.selectAll(".node")
       .attr("x1", function(d) { return ((d.x - (myWidth / 2)) / sfac) + (myWidth / 2) - 8; })
       .attr("y1", function(d) { return ((d.y - (myHeight / 2)) / sfac) + (myHeight / 2); })
       .attr("x2", function(d) { return ((d.x - (myWidth / 2)) / sfac) + (myWidth / 2) + 8;})
       .attr("y2", function(d) { return ((d.y - (myHeight / 2)) / sfac) + (myHeight / 2); })
       .transition().duration(mySec * BASE_TRANS)
       .style("opacity", "1.0");
}

///////////////////////////////////////////////////////////////////
//
// Build the graph, using the graph data as it exists BEFORE the "force"
// call.  The force() call changes some of the fields in the original import
// from link source and target indices to node object references.
//

function buildGraph(mySvg, myGraph) {
  mySvg.selectAll(".linkB")
      .data(myGraph.links)
      .enter().append("svg:line")
      .attr("class", "linkB")
      .attr("x1", function(d) { return myGraph.nodes[d.source].x; })
      .attr("y1", function(d) { return myGraph.nodes[d.source].y; })
      .attr("x2", function(d) { return myGraph.nodes[d.target].x; })
      .attr("y2", function(d) { return myGraph.nodes[d.target].y; })
      .style("stroke-width", LINK_WIDTH)
      .style("stroke", LINK_COL)
      .style("opacity", "0.0");

   mySvg.selectAll(".node")
      .data(myGraph.nodes)
      .enter().append("svg:line")
      .attr("class", "node")
      .attr("x1", function(d) { return d.x - NODE_HALF; })
      .attr("y1", function(d) { return d.y; })
      .attr("x2", function(d) { return d.x + NODE_HALF; })
      .attr("y2", function(d) { return d.y; })
      .style("stroke-width", NODE_SIZE)
      .style("stroke", NODE_COL)
      .style("opacity", "0.0");

  mySvg.selectAll(".linkF")
      .data(myGraph.links)
      .enter().append("svg:line")
      .attr("class", "linkF")
      .attr("x1", function(d) { return myGraph.nodes[d.source].x; })
      .attr("y1", function(d) { return myGraph.nodes[d.source].y; })
      .attr("x2", function(d) { return myGraph.nodes[d.target].x; })
      .attr("y2", function(d) { return myGraph.nodes[d.target].y; })
      .style("stroke-width", LINK_WIDTH)
      .style("stroke", LINK_COL)
      .style("opacity", "0.0");
}

///////////////////////////////////////////////////////////////////
//
// Build the graph, using the graph data as it exists AFTER the "force"
// call.  This one uses object references:
//

function buildGraphPost(mySvg, myGraph) {
  mySvg.selectAll(".linkB")
      .data(myGraph.links)
      .enter().append("svg:line")
      .attr("class", "linkB")
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; })
      .style("stroke-width", LINK_WIDTH)
      .style("stroke", LINK_COL)
      .style("opacity", "0.0");

   mySvg.selectAll(".node")
      .data(myGraph.nodes)
      .enter().append("svg:line")
      .attr("class", "node")
      .attr("x1", function(d) { return d.x - NODE_HALF; })
      .attr("y1", function(d) { return d.y; })
      .attr("x2", function(d) { return d.x + NODE_HALF; })
      .attr("y2", function(d) { return d.y; })
      .style("stroke-width", NODE_SIZE)
      .style("stroke", NODE_COL)
      .style("opacity", "0.0");

  mySvg.selectAll(".linkF")
      .data(myGraph.links)
      .enter().append("svg:line")
      .attr("class", "linkF")
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; })
      .style("stroke-width", LINK_WIDTH)
      .style("stroke", LINK_COL)
      .style("opacity", "0.0");
}

///////////////////////////////////////////////////////////////////
//
// Build the row sort. (Breadth first, from the highest degree node,
// traversing neighbors in the order of degree):
//

function sortGraph(myGraph) {
  myGraph.nodes.sort(compareNodes);
  var currNode = myGraph.nodes[0];
  currNode.row = 0;
  orderKids(currNode, 1);
}

function orderKids(myNode, currVal) {
  myNode.neighbors.sort(compareNodes);
  var toCheck = 0;
  for (var i = 0; i < myNode.neighbors.length; i++) {
    var checkNode = myNode.neighbors[i];
    if (checkNode.row === -1) {
      checkNode.row = currVal++;
      toCheck++;
    }
  }
  if (toCheck > 0) {
    for (var i = 0; i < myNode.neighbors.length; i++) {
      var checkNode = myNode.neighbors[i];
      if (checkNode.row !== -1) {
        currVal = orderKids(checkNode, currVal);
      }
    }
  }
  return (currVal);
}

///////////////////////////////////////////////////////////////////
//
// Link sorting
//

// Create what we want to sort:

function createSortingHat(myGraph) {
  var sorter = [];
  for (var i = 0; i < myGraph.links.length; i++) {
    var link = myGraph.links[i];
    var aGuy = {};
    aGuy.min = Math.min(link.source.row, link.target.row);
    aGuy.max = Math.max(link.source.row, link.target.row);
    aGuy.index = i;
    sorter.push(aGuy);
  }
  return (sorter);
}

function compareGuys(a, b) {
  if (a.min < b.min) {
     return -1;
  }
 if (a.min > b.min) {
     return 1;
  // mins are the same:
  } 
 if (a.max < b.max) {
     return -1;
  } 
 if (a.max > b.max) {
     return 1;
  }
  return 0;
}

// Horribly inefficient, but this is a small demo...

function sortLinks(myGraph) {
  var sortingHat = createSortingHat(myGraph);
  sortingHat.sort(compareGuys);
  var lastGuy = null;
  for (var i = 0; i < sortingHat.length; i++) {
    var aGuy = sortingHat[i];
    var useLink = myGraph.links[aGuy.index];
    useLink.col = i;
    if ((lastGuy != null) && (aGuy.min > lastGuy.min)) {
      var gotIt = false;
      for (var j = i - 1; j >= 0; j--) {
        if ((sortingHat[j].min < lastGuy.min) || (j === 0)) {  
          for (var k = 0; k < myGraph.nodes.length; k++) {
            var chkNode = myGraph.nodes[k];
            if (chkNode.row === lastGuy.min) {
              gotIt = true;
              myGraph.nodes[k].zoneMin = j;
              myGraph.nodes[k].zoneMax = i;
              break;
            }
          }
          if (gotIt) {
            break;
          }
        }
      }
    }
    lastGuy = aGuy;
  }
}

///////////////////////////////////////////////////////////////////
//
// Figure out the final node lengths:
// 

function boundNodes(myGraph) {
  for (var i = 0; i < myGraph.nodes.length; i++) {
    myGraph.nodes[i].minCol = Number.MAX_VALUE / 2;
    myGraph.nodes[i].maxCol = -Number.MAX_VALUE / 2;
  }

  for (var i = 0; i < myGraph.links.length; i++) {
    var link = myGraph.links[i];
    if (link.col < link.source.minCol) {
      link.source.minCol = link.col;
    }
    if (link.col > link.source.maxCol) {
      link.source.maxCol = link.col;
    }
    if (link.col < link.target.minCol) {
      link.target.minCol = link.col;
    }
    if (link.col > link.target.maxCol) {
     link.target.maxCol = link.col;
    }
  }
}

///////////////////////////////////////////////////////////////////
//
// For when you don't want to do anything at all:
//
 
function foo() {};

///////////////////////////////////////////////////////////////////
//
// NOW START DOING STUFF!
//
///////////////////////////////////////////////////////////////////

//
// Locate the SVG component in a centered DIV. Then add the supplemental text below it:
// 

var bsvg = d3.select(".inner").append("svg:svg")
    .attr("width", width)
    .attr("height", height)
    .style("background-color", "#FFFFFF");

var div = document.getElementById('data');
div.innerHTML = div.innerHTML +
       "<ul>" +
           "<li>The network is the Les Miserables character graph from: D. E. Knuth, The Stanford GraphBase: A Platform for Combinatorial Computing, Addison-Wesley, Reading, MA (1993).</li>" +
	   '<li>The d3.js demo is adapted from <a href="http://www.biofabric.org/gallery/pages/SuperQuickBioFabric.html">Super Quick BioFabric Demo</a></li>' +
       "</ul>";
           //'<li>Network data downloaded from: <a href="http://bl.ocks.org/mbostock/raw/4062045/miserables.json">bl.ocks.org</a></li>' +
           //'<li>This demo written using: <a href="http://d3js.org/">D3.js</a></li>' +
           //'<li>BioFabric project page: <a href="http://www.BioFabric.org">www.BioFabric.org</a></li>' +
           //'<li><i>Combing the Hairball</i> blog: <a href="http://biofabric.blogspot.com/">biofabric.blogspot.com</a></li>' +
           //'<li>BioFabric paper in <i>BMC BioInformatics</i>: <a href="http://www.biomedcentral.com/1471-2105/13/275/">http://www.biomedcentral.com/1471-2105/13/275/</a></li>' +
           //'<li>Follow <a href="http://twitter.com/wjrl59">@wjrl59</a> on Twitter for BioFabric news</li>' +

//
// Here is the D3 import and the guts of the page:
// 
// WARNING! The code has NOT been tested on different networks! Probably handles singleton nodes and duplicate links incorrectly! 
d3.json("miserables2.json", function(error, graph) {

// Firefox 17 was choking on the direct dx, dy settings, but did OK with the transform. What's up with that?

   bsvg.append("svg:text")
       .attr("class", "linktext00")
       .attr("transform", function(d) { return "translate(" + hw + "," + (hh - 50) + ")"; })
  //   .attr("dx", hw)
  //   .attr("dy", hh - 50)
       .text("A super-quick introduction to");
   bsvg.append("svg:text")
       .attr("class", "linktext0")
       .attr("transform", function(d) { return "translate(" + hw + "," + (hh + 50) + ")"; })
   //  .attr("dx", hw)
   //  .attr("dy", hh + 50)
       .text("BioFabric");

//
// Add and initialize some stuff to the graph we read in:
//

for (var i = 0; i < graph.nodes.length; i++) {
  graph.nodes[i].row = -1;
  graph.nodes[i].degree = 0;
  graph.nodes[i].zoneMin = -1000;
  graph.nodes[i].zoneMax = -1000;
  graph.nodes[i].neighbors = [];
}

//
// We calculate degree and record neighbors for later sorting: 
//

for (var i = 0; i < graph.links.length; i++) {
  var link = graph.links[i];
  graph.nodes[link.source].degree++;
  graph.nodes[link.target].degree++;
  graph.nodes[link.source].neighbors.push(graph.nodes[link.target]);
  graph.nodes[link.target].neighbors.push(graph.nodes[link.source]);
}

//
// Figure out the width and height we need to zoom to fit it all in.
// Note we are assuming more links than nodes: 
//

var gwidth = (2 * PAD) + (GRID * graph.links.length);
var gheight = (2 * PAD) + (GRID * graph.nodes.length);
var sfac = width / gwidth;

//
// Add the zooming transform at the top of the SVG tree. 
//

var svg = bsvg.append("svg:g").attr("transform", "translate(" + hw + "," + hh + ") scale(" + sfac + ") translate(-" + gwidth / 2 + ",-" + gheight / 2 + ")");

//
// Add the narrative text stub:
//

var myText = bsvg.append("svg:text")
       .attr("class", "narrText")
       .attr("dx", 10)
       .attr("dy", 30)
       .text("");

//
// Fire it up. Build the graph, initialize to a simple circle so force function
// always does the same thing, then run the force algorithm:
//

assignNodesToCircle(graph, gheight / 2.3, (gwidth / 2), gheight / 2);
buildGraph(svg, graph);
instantForce(svg, graph, gwidth, gheight);

//
// Start the animation. We then define a restart operation
// and the click handler to do the restart:
//

var postForce = false;
var myVar = setInterval(function(){myTimer()}, ONE_SEC);

//
// This is the function to restart the animation (needs the animation handle!), and the
// handler to call it:
//

function restart() {
  if (clickNum < DONE_INIT) {
    return;
  }
  clickNum = 0;
  dropAll(svg);
  myVar = setInterval(function(){myTimer()}, ONE_SEC);
}
bsvg.on("click", function() {restart();});

//
// Here are the time hacks for the animation:
//

// TODO: Tweak these to go MUCH faster

var ANI_START = 0;
var TITLE_FADE = 2;
var INSTALL_START = ANI_START + TITLE_FADE + 1;
var INSTALL_DUR = 4;
var POINTS_TO_LINES_INIT = INSTALL_START + INSTALL_DUR + 2;
var POINTS_TO_LINES_DUR = 4;
var NODES_TO_ROWS_INIT = POINTS_TO_LINES_INIT + POINTS_TO_LINES_DUR + 1;
var NODES_TO_ROWS_DUR = 4;
var LINKS_TO_COLS_INIT = NODES_TO_ROWS_INIT + NODES_TO_ROWS_DUR + 1;
var LINKS_TO_COLS_DUR = 4;
var GLYPH_INIT = LINKS_TO_COLS_INIT + LINKS_TO_COLS_DUR + 1;
var GLYPH_DUR = 6;
var NODE_LENGTH_INIT = GLYPH_INIT + GLYPH_DUR + 1;
var NODE_LENGTH_DUR = 4;
var LABEL_INIT = NODE_LENGTH_INIT + NODE_LENGTH_DUR + 1;
var LABEL_DUR = 4;
var COLOR_INIT = LABEL_INIT + LABEL_DUR + 1;
var COLOR_DUR = 4;
var FINAL_MSG_INIT = COLOR_INIT + COLOR_DUR + 1;
var FINAL_MSG_DUR = 0;
var TEXTA_INIT = FINAL_MSG_INIT + FINAL_MSG_DUR + 1;
var TEXTA_DUR = 1;
var TEXTB_INIT = TEXTA_INIT + TEXTA_DUR + 1;
var TEXTB_DUR = 1;
var TEXTC_INIT = TEXTB_INIT + TEXTB_DUR + 1;
var DONE_INIT = TEXTC_INIT + 1;
var WRAP_FADE = 2;

//
// The animation!
//

function myTimer() {
  if (clickNum === ANI_START) {
    if (postForce) {
      clickNum += TITLE_FADE;
    } else {
      ditchTitle(bsvg, TITLE_FADE);
    }
  } else if (clickNum === INSTALL_START) {
    if (postForce) {
      buildGraphPost(svg, graph);
    } else {
     postForce = true;
    }
    nextStep(bsvg, "Here's a traditional node-link network diagram, where nodes are represented by points:", installForceClosure(svg, gwidth, gheight, sfac, INSTALL_DUR));
  } else if (clickNum === POINTS_TO_LINES_INIT) {
    nextStep(bsvg, 'But BioFabric draws nodes as horizontal lines...', nodeToLinesClosure(svg, gwidth, POINTS_TO_LINES_DUR));
  } else if (clickNum === NODES_TO_ROWS_INIT) {
    sortGraph(graph);
    nextStep(bsvg, "...and then assigns each node to its own unique, sorted row:", nodesToRowsClosure(svg, NODES_TO_ROWS_DUR));
  } else if (clickNum === LINKS_TO_COLS_INIT) {
    sortLinks(graph);
    nextStep(bsvg, "Now slide the link ends along their node lines so they are parallel, and organized into 'edge wedges':", linksToVertClosure(svg, LINKS_TO_COLS_DUR)); 
  } else if (clickNum === GLYPH_INIT) {
    nextStep(bsvg, "Make the edges stand out, drawn in front and with prominent endpoint markers:", drawGlyphsClosure(svg, graph, GLYPH_DUR));
  } else if (clickNum === NODE_LENGTH_INIT) {
    boundNodes(graph);
    nextStep(bsvg, "Shorten the node lines: only as long as necessary!", setNodeLength(svg, NODE_LENGTH_DUR));
  } else if (clickNum === LABEL_INIT) {
    nextStep(bsvg, "Add labels to node lines and 'link zones':", drawLabelsClosure(svg, graph, LABEL_DUR));
  } else if (clickNum === COLOR_INIT) {
    nextStep(bsvg, "Finally, color the nodes and links in a cyclic pattern so they can be quickly scanned by eye, for the final BioFabric version:", colorNodesAndLinksClosure(svg, 1.43, COLOR_DUR));   
  } else if (clickNum === FINAL_MSG_INIT) {
    nextStepEx(bsvg, "", foo, 2000);
  } else if (clickNum === TEXTA_INIT) {
    //wrapItUp(svg, gheight, gwidth, WRAP_LOC_X, WRAP_FADE);
  } else if (clickNum === TEXTB_INIT) {
    svg.selectAll(".linktext3").transition().duration(WRAP_FADE * BASE_TRANS).style("opacity", 1);
  } else if (clickNum === TEXTC_INIT) {
    svg.selectAll(".linktext4").transition().duration(WRAP_FADE * BASE_TRANS).style("opacity", 1);
    clearInterval(myVar);
  }
  clickNum++;
}
});
</script>
</body>
</html>
